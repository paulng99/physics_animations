<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Convex Lens Image Formation</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MathJax -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script"></script>
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RJQ61GJDVS"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-RJQ61GJDVS');
    </script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
        }

        #three-container {
            width: 100%;
            height: 500px;
            background: #e2e8f0; /* slate-200 */
            cursor: move;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        }

        /* Custom Range Slider */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #cbd5e1; /* slate-300 */
            border-radius: 4px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #2563eb; /* blue-600 */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        /* Loading spinner */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            border: 3px solid rgba(37, 99, 235, 0.1);
            border-left-color: #2563eb;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
    </style>
</head>
<body class="antialiased min-h-screen flex flex-col">

    <!-- Navigation -->
    <nav class="bg-white border-b border-slate-200 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 h-16 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <a href="index.html" class="inline-flex items-center gap-2 text-slate-600 hover:text-blue-600 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                    <span class="font-medium" data-i18n="nav.back">Back to Home</span>
                </a>
                <div class="h-6 w-px bg-slate-300 mx-2"></div>
                <div class="w-8 h-8 bg-blue-600 rounded flex items-center justify-center text-white font-bold">3D</div>
                <span class="text-xl font-bold hidden sm:inline">PhysLab<span class="text-blue-600">3D</span></span>
            </div>
            
            <div class="flex items-center gap-4">
                <!-- Language Switcher -->
                <div class="flex gap-1 bg-slate-100 p-1 rounded-lg">
                    <button onclick="setLanguage('zh')" class="lang-btn px-3 py-1 rounded-md text-xs font-medium transition hover:bg-white hover:shadow-sm" data-lang="zh">繁</button>
                    <button onclick="setLanguage('cn')" class="lang-btn px-3 py-1 rounded-md text-xs font-medium transition hover:bg-white hover:shadow-sm" data-lang="cn">简</button>
                    <button onclick="setLanguage('en')" class="lang-btn px-3 py-1 rounded-md text-xs font-medium transition hover:bg-white hover:shadow-sm bg-white shadow-sm text-blue-600" data-lang="en">EN</button>
                </div>
            </div>
        </div>
    </nav>

    <main class="flex-grow max-w-7xl mx-auto px-4 py-8 space-y-6 w-full">
        
        <!-- Header Section -->
        <header class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
            <h1 class="text-3xl font-bold text-slate-800 mb-2" data-i18n="page.title">Convex Lens Image Formation</h1>
            <p class="text-slate-600 max-w-3xl leading-relaxed" data-i18n="page.description">
                Explore how a convex lens forms images. Adjust the object distance and focal length to see how real and virtual images are created. Observe the three principal rays in 3D space.
            </p>
        </header>

        <!-- Main Workspace -->
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            
            <!-- Left Column: Controls (4 cols) -->
            <div class="lg:col-span-4 space-y-6">
                
                <!-- Controls Panel -->
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 space-y-6">
                    <div class="flex justify-between items-center pb-4 border-b border-slate-100">
                        <h3 class="font-bold text-slate-800 flex items-center gap-2">
                            <svg class="w-5 h-5 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                            <span data-i18n="controls.title">Variables</span>
                        </h3>
                        <button id="reset-sim" class="text-xs text-blue-600 font-bold hover:text-blue-700 transition" data-i18n="controls.reset">Reset</button>
                    </div>

                    <!-- Object Distance (u) -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700" data-i18n="controls.u">Object Distance ($u$)</label>
                            <span id="val-u" class="text-sm font-bold text-blue-600 font-mono">20.0 cm</span>
                        </div>
                        <input type="range" id="slider-u" min="5" max="40" step="0.5" value="20">
                    </div>

                    <!-- Focal Length (f) -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700" data-i18n="controls.f">Focal Length ($f$)</label>
                            <span id="val-f" class="text-sm font-bold text-blue-600 font-mono">10.0 cm</span>
                        </div>
                        <input type="range" id="slider-f" min="5" max="25" step="0.5" value="10">
                    </div>

                    <!-- Object Height (h) -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700" data-i18n="controls.h">Object Height ($h_o$)</label>
                            <span id="val-h" class="text-sm font-bold text-blue-600 font-mono">5.0 cm</span>
                        </div>
                        <input type="range" id="slider-h" min="2" max="10" step="0.5" value="5">
                    </div>
                </div>

                <!-- Data Panel -->
                <div class="bg-slate-50 p-6 rounded-2xl border border-slate-200">
                    <h3 class="font-bold text-slate-800 text-sm uppercase tracking-wide mb-4" data-i18n="data.title">Real-time Data</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex justify-between items-center bg-white p-2 rounded border border-slate-100">
                            <span class="text-slate-500" data-i18n="data.v">Image Dist. ($v$)</span>
                            <span id="data-v" class="font-bold font-mono text-slate-800">20.00 cm</span>
                        </div>
                        <div class="flex justify-between items-center bg-white p-2 rounded border border-slate-100">
                            <span class="text-slate-500" data-i18n="data.m">Magnification ($m$)</span>
                            <span id="data-m" class="font-bold font-mono text-slate-800">-1.00</span>
                        </div>
                        <div class="flex justify-between items-center bg-white p-2 rounded border border-slate-100">
                            <span class="text-slate-500" data-i18n="data.type">Type</span>
                            <span id="data-type" class="font-bold text-emerald-600">Real, Inverted</span>
                        </div>
                    </div>
                </div>

                <!-- Physics Formula -->
                <div class="bg-slate-900 p-6 rounded-2xl shadow-lg text-white">
                    <h3 class="text-xs font-bold text-slate-400 uppercase tracking-widest mb-3" data-i18n="physics.title">Lens Formula</h3>
                    <div class="text-center text-xl font-serif mb-4">
                        $$ \frac{1}{f} = \frac{1}{u} + \frac{1}{v} $$
                    </div>
                    <div class="text-center text-lg font-serif mb-2 text-blue-300">
                        $$ m = -\frac{v}{u} $$
                    </div>
                    <p class="text-xs text-slate-400 text-center mt-4" data-i18n="physics.note">
                        Sign Convention: Real is positive (Cartesian).
                    </p>
                </div>

            </div>

            <!-- Right Column: Visualization & AI (8 cols) -->
            <div class="lg:col-span-8 space-y-6">
                
                <!-- 3D Canvas -->
                <div class="relative">
                    <div id="three-container"></div>
                    
                    <!-- Overlay Controls -->
                    <div class="absolute bottom-4 left-4 flex gap-2">
                        <div class="bg-white/90 backdrop-blur px-3 py-1 rounded-full text-xs font-bold text-slate-600 shadow-sm border border-slate-200">
                            <span class="w-2 h-2 rounded-full bg-blue-500 inline-block mr-1"></span> <span data-i18n="legend.object">Object</span>
                        </div>
                        <div class="bg-white/90 backdrop-blur px-3 py-1 rounded-full text-xs font-bold text-slate-600 shadow-sm border border-slate-200">
                            <span class="w-2 h-2 rounded-full bg-red-500 inline-block mr-1"></span> <span data-i18n="legend.image">Image</span>
                        </div>
                        <div class="bg-white/90 backdrop-blur px-3 py-1 rounded-full text-xs font-bold text-slate-600 shadow-sm border border-slate-200">
                            <span class="w-2 h-2 rounded-full bg-amber-500 inline-block mr-1"></span> <span data-i18n="legend.rays">Light Rays</span>
                        </div>
                    </div>
                    <div class="absolute top-4 right-4 text-[10px] font-bold text-slate-400 uppercase bg-white/50 px-2 py-1 rounded backdrop-blur">
                        <span data-i18n="canvas.hint">Drag to Rotate • Scroll to Zoom</span>
                    </div>
                </div>

                <!-- AI Explanation Section -->
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-bold text-slate-800 flex items-center gap-2">
                            <span class="text-xl">✨</span> <span data-i18n="ai.title">AI Physics Tutor</span>
                        </h2>
                    </div>
                    
                    <p class="text-slate-600 text-sm mb-4" data-i18n="ai.desc">
                        Confused about why the image is inverted or virtual? Ask our AI tutor to explain the current setup based on your slider values.
                    </p>

                    <button id="explain-button" class="w-full sm:w-auto flex items-center justify-center gap-2 px-6 py-2.5 bg-violet-600 text-white font-semibold rounded-xl hover:bg-violet-700 hover:-translate-y-0.5 transition-all shadow-sm">
                        <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        <span data-i18n="ai.btn">Explain Current Setup</span>
                    </button>

                    <!-- Loading State -->
                    <div id="gemini-loading" class="hidden mt-6 flex items-center justify-center p-4 bg-violet-50 rounded-xl">
                        <div class="spinner mr-3"></div>
                        <span class="text-violet-700 font-medium text-sm">Generating explanation...</span>
                    </div>

                    <!-- Result Area -->
                    <div id="gemini-explanation" class="hidden mt-6 p-6 bg-violet-50 border border-violet-100 rounded-xl text-slate-700 text-sm leading-relaxed prose prose-sm max-w-none">
                        <!-- AI Content -->
                    </div>
                </div>

                <!-- Feedback Section -->
                <div class="flex justify-end">
                    <button onclick="openFeedbackForm(event)" class="text-sm text-slate-500 hover:text-blue-600 font-medium flex items-center gap-1 transition">
                        <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                        <span data-i18n="btn.feedback">Send Feedback</span>
                    </button>
                </div>

            </div>
        </div>

    </main>

    <!-- Feedback Modal -->
    <div id="feedbackModal" class="hidden fixed inset-0 bg-slate-900/50 backdrop-blur-sm flex items-center justify-center p-4 z-[100]">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-md p-6 transform transition-all scale-100">
            <h3 class="text-xl font-bold text-slate-800 mb-4" data-i18n="feedback.title">Send Us Your Feedback</h3>
            <form onsubmit="submitFeedback(event)" class="space-y-4">
                <div>
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-1" data-i18n="feedback.email">Your Email</label>
                    <input type="email" placeholder="name@example.com" required class="w-full px-4 py-2 border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition">
                </div>
                <div>
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-1" data-i18n="feedback.message">Message</label>
                    <textarea placeholder="Tell us what you think..." rows="4" required class="w-full px-4 py-2 border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"></textarea>
                </div>
                <div class="flex gap-3 pt-2">
                    <button type="submit" class="flex-1 bg-blue-600 text-white py-2.5 rounded-xl font-semibold hover:bg-blue-700 transition shadow-sm" data-i18n="feedback.send">Send Feedback</button>
                    <button type="button" onclick="closeFeedbackForm()" class="flex-1 bg-slate-100 text-slate-700 py-2.5 rounded-xl font-semibold hover:bg-slate-200 transition" data-i18n="feedback.cancel">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Script Logic -->
    <script>
        // --- State Management ---
        const state = {
            u: 20, // Object distance
            f: 10, // Focal length
            h: 5   // Object height
        };

        // --- Three.js Setup ---
        let scene, camera, renderer, objectArrow, imageArrow, lensMesh, raysGroup, axisLine, fPointsGroup;
        const container = document.getElementById('three-container');

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf1f5f9); // slate-100

            // Camera
            camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            camera.position.set(20, 15, 40);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Optical Axis
            const axisGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-100, 0, 0),
                new THREE.Vector3(100, 0, 0)
            ]);
            const axisMat = new THREE.LineBasicMaterial({ color: 0x94a3b8 }); // slate-400
            axisLine = new THREE.Line(axisGeom, axisMat);
            scene.add(axisLine);

            // Lens (Visual only)
            const lensGeom = new THREE.SphereGeometry(10, 32, 32);
            lensGeom.scale(0.2, 1, 1); // Flatten to make lentil shape (rotated later)
            const lensMat = new THREE.MeshPhysicalMaterial({
                color: 0xa5f3fc, // cyan-200
                metalness: 0,
                roughness: 0,
                transmission: 0.9,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            lensMesh = new THREE.Mesh(lensGeom, lensMat);
            lensMesh.rotation.z = Math.PI / 2; // Orient correctly
            lensMesh.scale.set(1, 0.15, 1); // Thin convex lens
            scene.add(lensMesh);

            // Object Arrow (Blue)
            objectArrow = createArrow(0x2563eb);
            scene.add(objectArrow);

            // Image Arrow (Red)
            imageArrow = createArrow(0xdc2626);
            scene.add(imageArrow);

            // Rays Group
            raysGroup = new THREE.Group();
            scene.add(raysGroup);

            // Focal Points
            fPointsGroup = new THREE.Group();
            const fMat = new THREE.MeshBasicMaterial({ color: 0x475569 });
            const fGeom = new THREE.SphereGeometry(0.3, 16, 16);
            const f1 = new THREE.Mesh(fGeom, fMat);
            const f2 = new THREE.Mesh(fGeom, fMat);
            f1.name = "f1";
            f2.name = "f2";
            fPointsGroup.add(f1);
            fPointsGroup.add(f2);
            scene.add(fPointsGroup);

            // Grid (Floor) - Optional
            const gridHelper = new THREE.GridHelper(100, 50, 0xe2e8f0, 0xe2e8f0);
            gridHelper.position.y = -10;
            scene.add(gridHelper);

            updateSimulation();
            animate();
        }

        function createArrow(color) {
            const group = new THREE.Group();
            const stemGeom = new THREE.CylinderGeometry(0.2, 0.2, 1, 16);
            const headGeom = new THREE.ConeGeometry(0.5, 1, 16);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            
            const stem = new THREE.Mesh(stemGeom, mat);
            stem.position.y = 0.5; // Base at 0
            stem.name = "stem";
            
            const head = new THREE.Mesh(headGeom, mat);
            head.position.y = 1.5; // Top of stem
            head.name = "head";

            group.add(stem);
            group.add(head);
            return group;
        }

        function updateSimulation() {
            const u = state.u;
            const f = state.f;
            const h = state.h;

            // Physics Calculation: 1/f = 1/v + 1/u  => 1/v = 1/f - 1/u => v = (uf)/(u-f)
            // Note: In our 3D space, Object is at -u. Light travels left to right.
            // Sign convention: Real image v is positive (right). Virtual image v is negative (left).
            
            let v, m, isVirtual;
            
            if (Math.abs(u - f) < 0.1) {
                // At focus -> Infinity
                v = 1000; // Far away
                m = 1000;
                isVirtual = false; // or undefined
            } else {
                v = (u * f) / (u - f);
                m = -v / u; // Magnification
                isVirtual = v < 0; // If v is negative (same side as object), it's virtual
            }

            // Update UI Data
            document.getElementById('data-v').textContent = (Math.abs(v) > 500) ? "Infinity" : `${v.toFixed(2)} cm`;
            document.getElementById('data-m').textContent = (Math.abs(m) > 500) ? "Infinity" : `${m.toFixed(2)}`;
            
            let typeText = "";
            if (Math.abs(v) > 500) typeText = "At Infinity";
            else if (isVirtual) typeText = "Virtual, Erect";
            else typeText = "Real, Inverted";
            
            const typeEl = document.getElementById('data-type');
            typeEl.textContent = typeText;
            typeEl.className = `font-bold ${isVirtual ? 'text-violet-600' : 'text-emerald-600'}`;

            // --- 3D Updates ---

            // 1. Position Object
            objectArrow.position.set(-u, 0, 0);
            updateArrowScale(objectArrow, h);

            // 2. Position Image
            if (Math.abs(v) > 200) {
                imageArrow.visible = false;
            } else {
                imageArrow.visible = true;
                // For virtual image (v < 0), it appears on the left.
                // Physics: v is coordinate. If v = -20, it's at x = -20.
                // m determines orientation. If m > 0 (erect), if m < 0 (inverted).
                imageArrow.position.set(v, 0, 0);
                
                // Height calculation
                const h_prime = h * m; // m includes sign
                // createArrow builds an arrow pointing UP (y+).
                // If h_prime is negative, we rotate it or scale y by negative?
                // Scale y is easier, but arrow head might look weird if scaled negative.
                // Better to rotate Z if negative.
                
                const absH = Math.abs(h_prime);
                updateArrowScale(imageArrow, absH);
                
                if (h_prime < 0) {
                    imageArrow.rotation.z = Math.PI; // Point down
                    imageArrow.position.y = 0; // Pivot is at 0,0,0
                } else {
                    imageArrow.rotation.z = 0;
                }

                // Style for virtual (dashed? transparent?)
                imageArrow.children.forEach(mesh => {
                    mesh.material.opacity = isVirtual ? 0.5 : 1.0;
                    mesh.material.transparent = isVirtual;
                    mesh.material.emissive = isVirtual ? new THREE.Color(0x550000) : new THREE.Color(0x000000);
                });
            }

            // 3. Focal Points
            const f1 = fPointsGroup.getObjectByName("f1");
            const f2 = fPointsGroup.getObjectByName("f2");
            f1.position.set(-f, 0, 0);
            f2.position.set(f, 0, 0);

            // 4. Draw Rays
            drawRays(u, h, f, v, h * m);
        }

        function updateArrowScale(arrowGroup, height) {
            // Default arrow is height ~1.5 (stem 1 + head 0.5? No, geom sizes).
            // Stem height 1, y pos 0.5 -> range 0 to 1.
            // Head height 1, y pos 1.5 -> range 1 to 2.
            // Total height 2.
            const scale = height / 2;
            arrowGroup.scale.set(1, scale, 1);
        }

        function drawRays(u, h, f, v, h_prime) {
            // Clear old rays
            while(raysGroup.children.length > 0){ 
                raysGroup.remove(raysGroup.children[0]); 
            }

            // Material
            const rayMat = new THREE.LineBasicMaterial({ color: 0xf59e0b, linewidth: 2 }); // amber-500
            const dashMat = new THREE.LineDashedMaterial({ color: 0xf59e0b, dashSize: 1, gapSize: 1, opacity: 0.5, transparent: true });

            // Coordinates
            const objTop = new THREE.Vector3(-u, h, 0);
            const imgTop = new THREE.Vector3(v, h_prime, 0); // If virtual, v is negative
            const lensTop = new THREE.Vector3(0, h, 0); // Ray 1 hits here
            const lensCenter = new THREE.Vector3(0, 0, 0);
            const lensBot = new THREE.Vector3(0, h_prime, 0); // Ray 3 (if coming from F) hits roughly here? No.
            // Actually Ray 3 goes through F (-f, 0, 0) then hits lens.
            // Slope = h / (u - f). Hit height y_hit = slope * f? 
            // Let's stick to standard construction.

            // Ray 1: Parallel to Axis -> Lens -> Focal Point (Right) -> Image
            // Path: ObjectTop -> (0, h, 0) -> (f, 0, 0) -> ImageTop (or extend)
            const pts1 = [objTop.clone(), new THREE.Vector3(0, h, 0)];
            // From lens(0,h,0) through F(f,0,0) to Image.
            // If real image, just draw to image.
            // If virtual image, the ray CONTINUES diverging on the right, but we trace BACK to image.
            
            // Visual Ray (Right side)
            const ray1Start = new THREE.Vector3(0, h, 0);
            const fRight = new THREE.Vector3(f, 0, 0);
            const dir1 = new THREE.Vector3().subVectors(fRight, ray1Start).normalize();
            const farPoint1 = ray1Start.clone().add(dir1.clone().multiplyScalar(50)); // Draw far out
            
            pts1.push(farPoint1);
            raysGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts1), rayMat));

            // Virtual Extension for Ray 1?
            if (v < 0) {
                // Draw dashed line from Lens(0,h,0) back to ImageTop
                const dashGeom = new THREE.BufferGeometry().setFromPoints([ray1Start, imgTop]);
                const dashLine = new THREE.Line(dashGeom, dashMat);
                dashLine.computeLineDistances();
                raysGroup.add(dashLine);
            }


            // Ray 2: Through Center -> Undeviated
            // Path: ObjectTop -> (0,0,0) -> ImageTop
            const ray2Start = objTop.clone();
            const dir2 = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), ray2Start).normalize();
            const farPoint2 = ray2Start.clone().add(dir2.clone().multiplyScalar(60)); // Long ray
            
            const pts2 = [objTop.clone(), farPoint2];
            raysGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts2), rayMat));

            // Virtual Extension for Ray 2?
            if (v < 0) {
                 // The ray itself goes through (0,0,0) to right.
                 // The "extension" back to image is just the segment from 0,0,0 to image, which overlaps the incoming ray.
                 // Usually we don't need dashed line here, or just draw it to highlight.
            }

            // Ray 3: Through Focal Point (Left) -> Lens -> Parallel
            // Path: ObjectTop -> F_left(-f, 0, 0) -> Lens(0, y_hit, 0) -> Parallel (Right)
            // Intersection with x=0:
            // Line from (-u, h) through (-f, 0). Slope m3 = (0-h)/(-f - (-u)) = -h/(u-f).
            // y = m3(x - (-f)). At x=0: y_hit = m3(f) = -hf/(u-f).
            // Note: If u=f, ray is vertical, never hits lens? Parallel.
            
            if (Math.abs(u - f) > 0.1) {
                const y_hit = (-h * f) / (f - u); // Watch signs. u>0, f>0. if u>f, denom < 0.
                // Wait, standard slope formula.
                // Pt1 (-u, h), Pt2 (-f, 0).
                // x goes from -u to -f (delta u-f). y goes h to 0 (delta -h).
                // Slope = -h / (f-u)? No, (-f) - (-u) = u-f.
                // Slope = -h / (u-f).
                // Eq: y - 0 = slope * (x - (-f)). y = slope * (x+f).
                // At x=0: y = slope * f = -h*f / (u-f).
                
                // If u < f (inside focus), ray 3 is virtual? No, ray through F?
                // For u < f, the ray *appearing to come from* F? 
                // Or ray aiming at F?
                // Standard Ray 3: "Ray through F".
                // If u > f: Ray passes F(-f) then hits lens.
                // If u < f: Ray *as if coming from* F? No, ray passing through F(left)? 
                // Ray from tip through F(left) goes backwards (away from lens).
                // Convention: Ray aimed at F(right)? No.
                // Usually for u < f, we use the other F?
                // Let's keep it simple: Just draw 2 rays (Parallel and Center) is enough to define image.
                // Adding 3rd ray complicates virtual case logic visually.
                // I will stick to 2 rays for clarity in 3D, or implement 3rd only for Real images.
                
                if (u > f) {
                    const lensHit = new THREE.Vector3(0, y_hit, 0);
                    const pts3 = [objTop.clone(), lensHit]; // To lens
                    
                    // From lens parallel to axis
                    const farPoint3 = lensHit.clone().add(new THREE.Vector3(50, 0, 0));
                    pts3.push(farPoint3);
                    
                    raysGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts3), rayMat));
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            // Simple camera interaction
            renderer.render(scene, camera);
        }

        // --- Interaction ---
        document.getElementById('slider-u').addEventListener('input', (e) => {
            state.u = parseFloat(e.target.value);
            document.getElementById('val-u').textContent = state.u.toFixed(1) + " cm";
            updateSimulation();
        });
        document.getElementById('slider-f').addEventListener('input', (e) => {
            state.f = parseFloat(e.target.value);
            document.getElementById('val-f').textContent = state.f.toFixed(1) + " cm";
            updateSimulation();
        });
        document.getElementById('slider-h').addEventListener('input', (e) => {
            state.h = parseFloat(e.target.value);
            document.getElementById('val-h').textContent = state.h.toFixed(1) + " cm";
            updateSimulation();
        });

        document.getElementById('reset-sim').addEventListener('click', () => {
            state.u = 20; state.f = 10; state.h = 5;
            document.getElementById('slider-u').value = 20;
            document.getElementById('slider-f').value = 10;
            document.getElementById('slider-h').value = 5;
            document.getElementById('val-u').textContent = "20.0 cm";
            document.getElementById('val-f').textContent = "10.0 cm";
            document.getElementById('val-h').textContent = "5.0 cm";
            updateSimulation();
        });

        // Mouse Controls for Camera
        let isMouseDown = false;
        let startX, startY;
        let theta = Math.atan2(20, 40); // Initial pos 20, 40
        let phi = Math.acos(15 / Math.sqrt(20*20 + 15*15 + 40*40));
        let radius = Math.sqrt(20*20 + 15*15 + 40*40);

        container.addEventListener('mousedown', (e) => { isMouseDown = true; startX = e.clientX; startY = e.clientY; });
        window.addEventListener('mouseup', () => isMouseDown = false);
        window.addEventListener('mousemove', (e) => {
            if (!isMouseDown) return;
            const deltaX = (e.clientX - startX) * 0.005;
            const deltaY = (e.clientY - startY) * 0.005;
            startX = e.clientX; startY = e.clientY;

            theta -= deltaX;
            phi -= deltaY;
            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            camera.position.x = radius * Math.sin(phi) * Math.sin(theta);
            camera.position.y = radius * Math.cos(phi);
            camera.position.z = radius * Math.sin(phi) * Math.cos(theta);
            camera.lookAt(0, 0, 0);
        });
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            radius += e.deltaY * 0.05;
            radius = Math.max(10, Math.min(100, radius));
            camera.position.x = radius * Math.sin(phi) * Math.sin(theta);
            camera.position.y = radius * Math.cos(phi);
            camera.position.z = radius * Math.sin(phi) * Math.cos(theta);
            camera.lookAt(0, 0, 0);
        });

        // Initialize
        initThree();

        // --- Gemini API & Feedback (Skills) ---
        
        // Gemini API Function
        async function callGeminiAPI(userQuery, maxRetries = 3) {
            // NOTE: In a real app, do not expose API keys on the client side.
            // This is a demo setup.
            const apiKey = ""; // Environment variable would be injected here
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

            const systemPrompt = "You are a friendly physics tutor. Explain the convex lens image formation clearly based on the provided values (Object Distance u, Focal Length f). Explain if the image is Real/Virtual, Magnified/Diminished, and why. Keep it brief (under 100 words).";

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            let attempt = 0;
            while (attempt < maxRetries) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const result = await response.json();
                    return result.candidates?.[0]?.content?.parts?.[0]?.text || "No response generated.";
                } catch (error) {
                    console.error("API Error:", error);
                    attempt++;
                    await new Promise(r => setTimeout(r, 1000 * attempt));
                }
            }
            throw new Error("Failed to connect to AI service.");
        }

        document.getElementById('explain-button').addEventListener('click', async () => {
            const btn = document.getElementById('explain-button');
            const loading = document.getElementById('gemini-loading');
            const output = document.getElementById('gemini-explanation');
            
            btn.disabled = true;
            btn.classList.add('opacity-50');
            loading.classList.remove('hidden');
            output.classList.add('hidden');
            
            const prompt = `Current State: Object Distance u = ${state.u} cm, Focal Length f = ${state.f} cm, Object Height = ${state.h} cm. Explain the image formation.`;
            
            try {
                const text = await callGeminiAPI(prompt);
                output.innerHTML = text.replace(/\n/g, '<br>'); // Simple formatting
                output.classList.remove('hidden');
            } catch (err) {
                output.textContent = "Sorry, the AI tutor is currently unavailable. Please check your connection.";
                output.classList.remove('hidden');
            } finally {
                loading.classList.add('hidden');
                btn.disabled = false;
                btn.classList.remove('opacity-50');
            }
        });

        // Feedback Form Logic
        function openFeedbackForm(e) {
            e.preventDefault();
            document.getElementById('feedbackModal').classList.remove('hidden');
        }
        function closeFeedbackForm() {
            document.getElementById('feedbackModal').classList.add('hidden');
        }
        async function submitFeedback(e) {
            e.preventDefault();
            // Simulate submission
            alert("Thank you for your feedback!");
            closeFeedbackForm();
        }

        // --- Language System ---
        const translations = {
            en: {
                'nav.back': 'Back to Home',
                'page.title': 'Convex Lens Image Formation',
                'page.description': 'Explore how a convex lens forms images. Adjust the object distance and focal length to see how real and virtual images are created. Observe the three principal rays in 3D space.',
                'controls.title': 'Variables',
                'controls.reset': 'Reset',
                'controls.u': 'Object Distance ($u$)',
                'controls.f': 'Focal Length ($f$)',
                'controls.h': 'Object Height ($h_o$)',
                'data.title': 'Real-time Data',
                'data.v': 'Image Dist. ($v$)',
                'data.m': 'Magnification ($m$)',
                'data.type': 'Type',
                'physics.title': 'Lens Formula',
                'physics.note': 'Sign Convention: Real is positive (Cartesian).',
                'legend.object': 'Object',
                'legend.image': 'Image',
                'legend.rays': 'Light Rays',
                'canvas.hint': 'Drag to Rotate • Scroll to Zoom',
                'ai.title': 'AI Physics Tutor',
                'ai.desc': 'Confused about why the image is inverted or virtual? Ask our AI tutor to explain the current setup.',
                'ai.btn': 'Explain Current Setup',
                'btn.feedback': 'Send Feedback',
                'feedback.title': 'Send Us Your Feedback',
                'feedback.email': 'Your Email',
                'feedback.message': 'Message',
                'feedback.send': 'Send Feedback',
                'feedback.cancel': 'Cancel'
            },
            zh: {
                'nav.back': '返回首頁',
                'page.title': '凸透鏡成像模擬',
                'page.description': '探索凸透鏡如何形成影像。調整物距和焦距，觀察實像與虛像的產生。在 3D 空間中觀察三條主要光線。',
                'controls.title': '變數控制',
                'controls.reset': '重設',
                'controls.u': '物距 ($u$)',
                'controls.f': '焦距 ($f$)',
                'controls.h': '物體高度 ($h_o$)',
                'data.title': '即時數據',
                'data.v': '像距 ($v$)',
                'data.m': '放大倍率 ($m$)',
                'data.type': '性質',
                'physics.title': '透鏡公式',
                'physics.note': '符號約定：實像為正（笛卡爾坐標）。',
                'legend.object': '物體',
                'legend.image': '影像',
                'legend.rays': '光線',
                'canvas.hint': '拖曳旋轉 • 滾輪縮放',
                'ai.title': 'AI 物理導師',
                'ai.desc': '不明白為什麼影像是倒立或虛像？詢問我們的 AI 導師來解釋當前的設置。',
                'ai.btn': '解釋當前設置',
                'btn.feedback': '發送反饋',
                'feedback.title': '發送您的反饋',
                'feedback.email': '您的電子郵件',
                'feedback.message': '訊息',
                'feedback.send': '發送反饋',
                'feedback.cancel': '取消'
            },
            cn: {
                'nav.back': '返回首页',
                'page.title': '凸透镜成像模拟',
                'page.description': '探索凸透镜如何形成影像。调整物距和焦距，观察实像与虚像的产生。在 3D 空间中观察三条主要光线。',
                'controls.title': '变数控制',
                'controls.reset': '重设',
                'controls.u': '物距 ($u$)',
                'controls.f': '焦距 ($f$)',
                'controls.h': '物体高度 ($h_o$)',
                'data.title': '即时数据',
                'data.v': '像距 ($v$)',
                'data.m': '放大倍率 ($m$)',
                'data.type': '性质',
                'physics.title': '透镜公式',
                'physics.note': '符号约定：实像为正（笛卡尔坐标）。',
                'legend.object': '物体',
                'legend.image': '影像',
                'legend.rays': '光线',
                'canvas.hint': '拖曳旋转 • 滚轮缩放',
                'ai.title': 'AI 物理导师',
                'ai.desc': '不明白为什么影像是倒立或虚像？询问我们的 AI 导师来解释当前的设置。',
                'ai.btn': '解释当前设置',
                'btn.feedback': '发送反馈',
                'feedback.title': '发送您的反馈',
                'feedback.email': '您的电子邮件',
                'feedback.message': '讯息',
                'feedback.send': '发送反馈',
                'feedback.cancel': '取消'
            }
        };

        function setLanguage(lang) {
            localStorage.setItem('preferred_language', lang);
            document.documentElement.lang = lang === 'cn' ? 'zh-CN' : lang === 'zh' ? 'zh-TW' : 'en';
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[lang] && translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });

            // Re-render MathJax
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise();
            }
        }

        // Init Language
        const savedLang = localStorage.getItem('preferred_language') || 'en';
        setLanguage(savedLang);

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speed of Sound Experiment</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font for a clean look */
        body {
            font-family: 'Inter', sans-serif;
        }
        
        /* Define the animation for the sound wave moving */
        @keyframes move-wave {
            0% {
                left: 10%; /* Start at the sound source */
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            30% {
                left: 30%; /* Arrive at Mic A */
                opacity: 1;
            }
            70% {
                left: 70%; /* Arrive at Mic B */
                opacity: 1;
            }
            100% {
                left: 90%;
                opacity: 0;
            }
        }
        
        /* Animation class to be added by JS */
        .wave-animated {
            animation: move-wave 5s linear forwards;
        }

        /* Flashing animation for microphones */
        @keyframes flash {
            0%, 100% {
                transform: scale(1);
                background-color: #3b82f6; /* blue-500 */
            }
            50% {
                transform: scale(1.1);
                background-color: #60a5fa; /* blue-400 */
            }
        }
        
        .flash {
            animation: flash 0.5s ease-in-out;
        }

        /* Hammer swing animation */
        @keyframes hammer-swing {
            0% { transform: rotate(10deg); }
            50% { transform: rotate(-25deg); }
            100% { transform: rotate(10deg); }
        }

        .hammer-animated {
            animation: hammer-swing 0.5s ease-in-out;
        }

        /* Simple icon for the hammer using SVG */
        .hammer-icon {
            width: 40px;
            height: 40px;
            transform-origin: bottom right;
        }
        
        /* Simple icon for the microphone */
        .mic-icon {
            width: 20px;
            height: 40px;
        }
        
        /* Add cursor styles for dragging */
        #micB {
            cursor: grab;
        }
        body.dragging, body.dragging #micB {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-4xl bg-gray-800 rounded-lg shadow-2xl p-6 relative overflow-hidden">
        
        <h1 class="text-2xl font-bold text-center mb-4">Speed of Sound Experiment</h1>
        
        <!-- Animation Scene -->
        <div id="scene" class="w-full h-64 bg-gray-700 rounded-lg relative border-2 border-gray-600 p-4">
            
            <!-- Bench Top -->
            <div class="absolute bottom-16 left-0 right-0 h-1 bg-gray-400 border-b-2 border-gray-500"></div>
            <span class="absolute bottom-10 left-4 text-sm text-gray-300">Bench Top</span>
            
            <!-- Sound Source (Hammer & Plate) -->
            <div id="sound-source" class="absolute z-10" style="left: 10%; bottom: 4.5rem;">
                <!-- Plate -->
                <div class="w-3 h-10 bg-gray-400 rounded-sm translate-y-1"></div>
                <!-- Hammer -->
                <svg id="hammer" class="hammer-icon absolute bottom-0 -right-8" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M80 60H30V40H80L90 50L80 60Z" fill="#9CA3AF"/> <!-- gray-400 -->
                    <path d="M20 70H40V95H20V70Z" fill="#78350F"/> <!-- amber-900 -->
                </svg>
            </div>
            
            <!-- Microphone A (START) -->
            <div id="micA" class="absolute z-10 flex flex-col items-center" style="left: 30%; bottom: 4.5rem; transform: translateX(-50%);">
                <div class="mic-icon bg-blue-500 rounded-t-full rounded-b-md border-2 border-blue-300"></div>
                <span class="text-xs font-bold mt-1">A</span>
                <span class="text-xs text-blue-300">(START)</span>
            </div>
            
            <!-- Microphone B (STOP) -->
            <div id="micB" class="absolute z-10 flex flex-col items-center" style="left: 70%; bottom: 4.5rem; transform: translateX(-50%);">
                <div class="mic-icon bg-red-500 rounded-t-full rounded-b-md border-2 border-red-300"></div>
                <span class="text-xs font-bold mt-1">B</span>
                <span class="text-xs text-red-300">(STOP)</span>
            </div>

            <!-- Distance Marker -->
            <div id="distance-marker-line" class="absolute h-px border-t-2 border-dashed border-gray-400" style="left: 30%; width: 40%; bottom: 3rem;">
                <div id="distance-marker-text" class="absolute -top-6 left-1/2 -translate-x-1/2 bg-gray-700 px-2 text-sm">d = 0.280 m</div>
            </div>
            
            <!-- Timer -->
            <div id="timer" class="absolute top-4 left-1/2 -translate-x-1/2 bg-gray-900 rounded-md p-4 w-40 border-2 border-gray-600">
                <div class="text-center text-xs text-gray-400 mb-1">TIMER</div>
                <div id="timer-display" class="text-center text-3xl font-mono text-green-400 bg-black rounded p-2">
                    000 µs
                </div>
            </div>

            <!-- Sound Wavefront -->
            <div id="wavefront" class="absolute top-0 bottom-0 w-1 bg-blue-300 rounded-full" style="left: 10%; opacity: 0;"></div>

        </div>

        <!-- Controls -->
        <div class="flex flex-col sm:flex-row justify-center items-center mt-6 space-y-4 sm:space-y-0 sm:space-x-4">
            <!-- New Distance Input -->
            <div class="flex items-center space-x-2">
                <label for="distance-input" class="text-gray-300 font-semibold">Distance (m):</label>
                <input type="number" id="distance-input" value="0.280" step="0.001" class="bg-gray-900 text-white w-28 p-2 rounded-lg border border-gray-600 focus:ring-2 focus:ring-blue-500 focus:outline-none">
            </div>
            
            <button id="run-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 w-full sm:w-auto">
                Run Experiment
            </button>
        </div>

        <!-- Calculation Display -->
        <div id="calculation-box" class="mt-6 p-4 bg-gray-700 rounded-lg text-center hidden">
            <h3 class="text-lg font-semibold mb-2">Calculation</h3>
            <p id="calc-time" class="font-mono text-lg">
                Average time (Δt) = 820 µs = 820 x 10<sup>-6</sup> s
            </p>
            <p class="font-mono text-lg mt-2">
                Speed (v) = distance / time = d / Δt
            </p>
            <p id="calc-step" class="font-mono text-lg mt-2">
                v = 0.280 m / (820 x 10<sup>-6</sup> s)
            </p>
            <p id="calc-result" class="font-mono text-xl font-bold mt-2 text-green-400">
                v ≈ 341.5 m/s
            </p>
        </div>

    </div>

    <script>
        // Get all the DOM elements
        const runButton = document.getElementById('run-button');
        const hammer = document.getElementById('hammer');
        const wavefront = document.getElementById('wavefront');
        const micA = document.getElementById('micA');
        const micB = document.getElementById('micB');
        const timerDisplay = document.getElementById('timer-display');
        const calculationBox = document.getElementById('calculation-box');
        const scene = document.getElementById('scene');
        
        // New elements for dynamic calculation
        const distanceInput = document.getElementById('distance-input');
        const distanceMarkerText = document.getElementById('distance-marker-text');
        const distanceMarkerLine = document.getElementById('distance-marker-line');
        const calcTime = document.getElementById('calc-time');
        const calcStep = document.getElementById('calc-step');
        const calcResult = document.getElementById('calc-result');

        // Animation parameters
        const ANIMATION_DURATION_MS = 5000; // 5 seconds total
        const START_TIME_RATIO = 0.30; // Wave reaches Mic A at 30% of duration
        const STOP_TIME_RATIO = 0.70;  // Wave reaches Mic B at 70% of duration
        const FINAL_TIME_US = 820; // The average time from the data
        
        // Calculate the real time in ms when events happen
        const animStartTimeMs = ANIMATION_DURATION_MS * START_TIME_RATIO;
        const animStopTimeMs = ANIMATION_DURATION_MS * STOP_TIME_RATIO;
        const animTimeBetweenMics = animStopTimeMs - animStartTimeMs;
        
        let animationFrameId = null;
        let animationStartTime = 0;
        let timerStarted = false;
        let timerStopped = false;

        // --- Drag and Drop Logic ---
        let isDragging = false;
        const micAPercent = 30; // Microphone A's fixed position
        const minMicBPercent = micAPercent + 2; // Min drag position
        const maxMicBPercent = 90; // Max drag position
        
        // This constant defines the relationship between percentage points and meters
        // Original: (70% - 30%) = 40% -> 0.280m. So, 0.280m / 40% = 0.007 m/percent
        const metersPerPercent = 0.007; 

        micB.addEventListener('mousedown', startDrag);
        micB.addEventListener('touchstart', startDrag, { passive: false });

        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);

        document.addEventListener('mousemove', onDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });

        function startDrag(e) {
            if (runButton.disabled) return; // Don't allow dragging during animation
            e.preventDefault();
            isDragging = true;
            document.body.classList.add('dragging');
        }

        function onDrag(e) {
            if (!isDragging) return;
            e.preventDefault();

            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const sceneRect = scene.getBoundingClientRect();
            const sceneWidth = sceneRect.width;

            // Calculate mouse position as a percentage of scene width
            let newPercent = ((clientX - sceneRect.left) / sceneWidth) * 100;
            
            // Constrain the position
            newPercent = Math.max(minMicBPercent, Math.min(maxMicBPercent, newPercent));

            // Calculate distance based on new percentage
            let distance = (newPercent - micAPercent) * metersPerPercent;
            
            // Update the input field
            distanceInput.value = distance.toFixed(3);
            
            // Update visuals
            updateVisualsFromDistance(distance, newPercent);
        }

        function endDrag() {
            if (!isDragging) return;
            isDragging = false;
            document.body.classList.remove('dragging');
            
            // Final update to calculation box if it's open
            if (!calculationBox.classList.contains('hidden')) {
                showCalculation();
            }
        }
        // --- End Drag and Drop Logic ---


        runButton.addEventListener('click', runAnimation);
        distanceInput.addEventListener('input', handleDistanceInputChange);

        // Update visuals on initial load from default input value
        handleDistanceInputChange(); 

        function handleDistanceInputChange() {
            let distance = parseFloat(distanceInput.value) || 0;
            
            // Calculate new percentage from distance
            // distance = (newPercent - micAPercent) * metersPerPercent
            // newPercent = (distance / metersPerPercent) + micAPercent
            let newPercent = (distance / metersPerPercent) + micAPercent;

            // Constrain percentage based on valid distance input
            newPercent = Math.max(minMicBPercent, Math.min(maxMicBPercent, newPercent));

            updateVisualsFromDistance(distance, newPercent);
        }

        function updateVisualsFromDistance(distance, micBPercent) {
            // Update Mic B position
            micB.style.left = `${micBPercent}%`;
            
            // Update distance marker line width
            distanceMarkerLine.style.width = `${micBPercent - micAPercent}%`;

            // Update distance marker text
            distanceMarkerText.textContent = `d = ${distance.toFixed(3)} m`;

            // If calculation is already visible, update it
            if (!calculationBox.classList.contains('hidden') && !isDragging) {
                showCalculation();
            }
        }
        
        function runAnimation() {
            // 1. Reset everything
            runButton.disabled = true;
            runButton.textContent = 'Running...';
            calculationBox.classList.add('hidden');
            timerDisplay.textContent = '000 µs';
            timerDisplay.classList.remove('text-red-400');
            timerDisplay.classList.add('text-green-400');
            
            // Remove animation classes to reset
            wavefront.classList.remove('wave-animated');
            hammer.classList.remove('hammer-animated');
            micA.classList.remove('flash');
            micB.classList.remove('flash');
            
            // Force reflow to restart CSS animation
            void wavefront.offsetWidth; 
            
            timerStarted = false;
            timerStopped = false;

            // Update distance marker in scene just in case it was changed
            handleDistanceInputChange();

            // 2. Start hammer animation
            hammer.classList.add('hammer-animated');
            
            // 3. Start wavefront after a short delay (for hammer)
            setTimeout(() => {
                wavefront.classList.add('wave-animated');
                animationStartTime = performance.now();
                
                // 4. Start the update loop for the timer
                animationFrameId = requestAnimationFrame(updateTimer);
            }, 300); // 300ms delay

            // 5. Reset button after animation finishes
            setTimeout(() => {
                runButton.disabled = false;
                runButton.textContent = 'Run Experiment';
                wavefront.classList.remove('wave-animated');
                hammer.classList.remove('hammer-animated');
            }, ANIMATION_DURATION_MS + 300);
        }

        function updateTimer(timestamp) {
            const elapsedMs = timestamp - animationStartTime;

            // Check if wave has reached Mic A
            if (!timerStarted && elapsedMs >= animStartTimeMs) {
                timerStarted = true;
                micA.classList.add('flash');
            }

            // Update timer display if it's running
            if (timerStarted && !timerStopped) {
                // Calculate how far we are between Mic A and Mic B
                const timeSinceStart = elapsedMs - animStartTimeMs;
                let displayTime = (timeSinceStart / animTimeBetweenMics) * FINAL_TIME_US;

                if (displayTime >= FINAL_TIME_US) {
                    // Stop the timer
                    displayTime = FINAL_TIME_US;
                    timerStopped = true;
                    micB.classList.add('flash');
                    timerDisplay.classList.remove('text-green-400');
                    timerDisplay.classList.add('text-red-400'); // Show stop color
                    
                    // Show the calculation with the current distance
                    showCalculation();
                }

                timerDisplay.textContent = Math.floor(displayTime).toString().padStart(3, '0') + ' µs';
            }

            // Continue loop if timer hasn't stopped
            if (!timerStopped) {
                animationFrameId = requestAnimationFrame(updateTimer);
            } else {
                cancelAnimationFrame(animationFrameId);
            }
        }

        function showCalculation() {
            const distance = parseFloat(distanceInput.value) || 0;
            const timeSec = FINAL_TIME_US / 1_000_000; // Convert µs to s
            let speed = 0;

            if (timeSec > 0) {
                speed = distance / timeSec;
            }

            // Update calculation text
            calcTime.innerHTML = `Average time (Δt) = ${FINAL_TIME_US} µs = ${FINAL_TIME_US} x 10<sup>-6</sup> s`;
            calcStep.textContent = `v = ${distance.toFixed(3)} m / (${FINAL_TIME_US} x 10\u207B\u2076 s)`; // Using unicode for superscripts
            calcResult.textContent = `v \u2248 ${speed.toFixed(1)} m/s`; // \u2248 is ≈

            // Show the box
            calculationBox.classList.remove('hidden');
        }

    </script>
</body>
</html>

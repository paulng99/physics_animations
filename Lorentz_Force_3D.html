<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Force on Conductor Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        /* Custom scrollbar for panel */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        /* DAT.GUI Customization overrides */
        .dg.main {
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
    </style>
</head>
<body class="font-sans text-gray-800">

    <!-- UI Panel -->
    <div id="ui-panel" class="absolute top-5 left-5 w-96 bg-white/95 backdrop-blur-md p-6 rounded-xl shadow-2xl border border-gray-200 z-10 max-h-[90vh] overflow-y-auto transition-all duration-300">
        <h1 class="text-2xl font-bold text-gray-900 border-b-2 border-blue-600 pb-3 mb-4 flex justify-between items-center flex-wrap gap-2">
            <span data-i18n="page.title">Lorentz Force Simulation</span>
            <div class="flex gap-1">
                 <button onclick="setLanguage('zh')" class="lang-btn px-2 py-1 rounded text-xs font-medium transition hover:bg-blue-100 bg-gray-100" data-lang="zh">繁</button>
                 <button onclick="setLanguage('cn')" class="lang-btn px-2 py-1 rounded text-xs font-medium transition hover:bg-blue-100 bg-gray-100" data-lang="cn">简</button>
                 <button onclick="setLanguage('en')" class="lang-btn px-2 py-1 rounded text-xs font-medium transition hover:bg-blue-100 bg-blue-600 text-white" data-lang="en">EN</button>
            </div>
        </h1>
        
        <div id="explanation-content" class="space-y-4">
            <p class="text-sm text-gray-600 leading-relaxed" data-i18n="page.desc">
                Interactive visualization of the magnetic force on a current-carrying rod placed on inclined rails.
            </p>
            
            <div>
                <h2 class="text-lg font-semibold text-gray-800 mb-2" data-i18n="legend.title">Vector Legend</h2>
                <ul class="space-y-2 text-sm">
                    <li class="flex items-center gap-2">
                        <span class="w-3 h-3 rounded-full bg-red-600 shadow-sm ring-1 ring-red-200"></span>
                        <span class="text-gray-700" data-i18n="legend.force"><strong>Force (F)</strong>: Resulting Lorentz force</span>
                    </li>
                    <li class="flex items-center gap-2">
                        <span class="w-3 h-3 rounded-full bg-green-600 shadow-sm ring-1 ring-green-200"></span>
                        <span class="text-gray-700" data-i18n="legend.current"><strong>Current (I)</strong>: Direction of current</span>
                    </li>
                    <li class="flex items-center gap-2">
                        <span class="w-3 h-3 rounded-full bg-orange-500 shadow-sm ring-1 ring-orange-200"></span>
                        <span class="text-gray-700" data-i18n="legend.field"><strong>Magnetic Field (B)</strong>: External vertical field</span>
                    </li>
                </ul>
            </div>

            <div>
                <h2 class="text-lg font-semibold text-gray-800 mb-2" data-i18n="physics.title">Physics Principle</h2>
                <p class="text-sm text-gray-600 mb-2" data-i18n="physics.desc">The magnetic force is defined by the cross product:</p>
                <div class="bg-gray-50 border-l-4 border-blue-600 p-3 rounded-r-lg text-center font-serif text-lg text-blue-900 italic shadow-inner">
                    F = I (L &times; B)
                </div>
                <p class="text-xs text-gray-500 mt-2" data-i18n="physics.hint">
                    Adjust the parameters below to see how the force vector changes direction and magnitude.
                </p>
            </div>

            <div class="pt-2 space-y-2">
                <button onclick="snapToObserverView()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 px-4 rounded-lg transition-colors shadow-sm flex items-center justify-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>
                    <span data-i18n="btn.sideview">Switch to Side View (2D)</span>
                </button>
                <button onclick="resetCamera()" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2.5 px-4 rounded-lg transition-colors shadow-sm flex items-center justify-center gap-2 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>
                    <span data-i18n="btn.reset">Reset 3D View</span>
                </button>
            </div>
        </div>
    </div>

    <div id="canvas-container" class="absolute top-0 left-0 w-full h-full z-0"></div>
    
    <div id="controls-hint" class="absolute bottom-6 right-6 bg-gray-900/80 backdrop-blur-sm text-white px-5 py-3 rounded-full text-sm font-medium pointer-events-none z-10 shadow-lg border border-gray-700" data-i18n="controls.hint">
        Left Click: Rotate | Right Click: Pan | Scroll: Zoom
    </div>

    <script>
        // --- 1. Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        scene.fog = new THREE.Fog(0xf0f0f0, 20, 100);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Resize Listener
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 2. Objects ---

        // State variables
        const state = {
            angle: 30, // degrees
            currentDirection: 1, // 1: Q->P (Into screen in side view), -1: P->Q
            bFieldDirection: -1, // -1: Down, 1: Up
            rodPosition: 0,
            showVectors: true
        };

        const materials = {
            rail: new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.6, roughness: 0.4 }), // Slate-400
            rod: new THREE.MeshStandardMaterial({ color: 0xf59e0b, metalness: 0.3, roughness: 0.2 }), // Amber-500
            battery: new THREE.MeshBasicMaterial({ color: 0x333333 }),
            wire: new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }),
            arrowForce: 0xdc2626, // Red-600
            arrowB: 0xf97316,     // Orange-500
            arrowI: 0x16a34a      // Green-600 (Changed from Blue to match Physics Standards for Motion/Flow)
        };

        // Groups
        const assemblyGroup = new THREE.Group();
        scene.add(assemblyGroup);

        const inclineGroup = new THREE.Group();
        assemblyGroup.add(inclineGroup);

        // Rails
        const railLength = 12;
        const railSep = 4;
        const railGeo = new THREE.BoxGeometry(0.2, 0.2, railLength);
        
        const leftRail = new THREE.Mesh(railGeo, materials.rail);
        leftRail.position.set(0, 0, -railSep/2);
        inclineGroup.add(leftRail);

        const rightRail = new THREE.Mesh(railGeo, materials.rail);
        rightRail.position.set(0, 0, railSep/2);
        inclineGroup.add(rightRail);

        // Rod
        const rodGeo = new THREE.CylinderGeometry(0.3, 0.3, railSep + 1, 32);
        const rod = new THREE.Mesh(rodGeo, materials.rod);
        rod.rotation.x = Math.PI / 2;
        rod.position.set(0, 0.3, 0); 
        inclineGroup.add(rod);

        // Ground Plane (Reference)
        const gridHelper = new THREE.GridHelper(30, 30, 0xcccccc, 0xe5e5e5);
        scene.add(gridHelper);

        // Labels / Text (Simple Sprites)
        function makeTextSprite(message, fontsize=24) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = "Bold " + fontsize + "px Inter, Arial";
            const metrics = ctx.measureText(message);
            const width = metrics.width;
            
            canvas.width = width + 20;
            canvas.height = fontsize + 20;
            
            ctx.font = "Bold " + fontsize + "px Inter, Arial";
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = "#1e293b"; // Slate-800
            ctx.fillText(message, 10, fontsize);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width/20, canvas.height/20, 1);
            return sprite;
        }

        const lblQ = makeTextSprite("Q");
        const lblP = makeTextSprite("P");
        inclineGroup.add(lblQ);
        inclineGroup.add(lblP);

        // Magnetic Field Arrows (Grid)
        const bFieldGroup = new THREE.Group();
        scene.add(bFieldGroup);
        
        function updateBField() {
            while(bFieldGroup.children.length > 0){ 
                bFieldGroup.remove(bFieldGroup.children[0]); 
            }
            
            const arrowLen = 2;
            const color = materials.arrowB;
            const dir = new THREE.Vector3(0, state.bFieldDirection, 0);
            
            for(let x = -5; x <= 5; x+=3) {
                for(let z = -5; z <= 5; z+=3) {
                    const origin = new THREE.Vector3(x, 5, z);
                    const arrow = new THREE.ArrowHelper(dir, origin, arrowLen, color, 0.5, 0.3);
                    bFieldGroup.add(arrow);
                }
            }
        }

        // Vectors on the Rod
        const forceArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 3, materials.arrowForce, 0.8, 0.5);
        const currentArrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,-1), new THREE.Vector3(0,0,0), 3, materials.arrowI, 0.8, 0.5);
        scene.add(forceArrow);
        scene.add(currentArrow);

        // Battery schematic (Visual only)
        const wireGroup = new THREE.Group();
        inclineGroup.add(wireGroup);
        
        function updateWires() {
            while(wireGroup.children.length > 0) wireGroup.remove(wireGroup.children[0]);
            
            const topX = -railLength/2;
            const zL = -railSep/2; // Left Rail
            const zR = railSep/2;  // Right Rail
            
            // Battery box
            const battGeo = new THREE.BoxGeometry(1, 0.5, 0.5);
            const batt = new THREE.Mesh(battGeo, materials.battery);
            batt.position.set(topX - 1, 0, 0); // Behind the rails
            wireGroup.add(batt);
            
            // Wires
            const points = [];
            points.push(new THREE.Vector3(topX, 0, zL)); // Top Left Rail
            points.push(new THREE.Vector3(topX - 1, 0, zL)); // Out
            points.push(new THREE.Vector3(topX - 1, 0, -0.6)); // To Battery +
            
            points.push(new THREE.Vector3(topX - 1, 0, 0.6)); // From Battery -
            points.push(new THREE.Vector3(topX - 1, 0, zR)); 
            points.push(new THREE.Vector3(topX, 0, zR)); // Top Right Rail
            
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(lineGeo, materials.wire);
            wireGroup.add(line);
            
            // Battery Polarity Sign
            const plus = makeTextSprite("+", 20);
            const minus = makeTextSprite("-", 20);
            
            if (state.currentDirection === 1) {
                plus.position.set(topX - 1, 0.5, zL);
                minus.position.set(topX - 1, 0.5, zR);
            } else {
                plus.position.set(topX - 1, 0.5, zR);
                minus.position.set(topX - 1, 0.5, zL);
            }
            wireGroup.add(plus);
            wireGroup.add(minus);
        }

        // --- 3. Physics & Updates ---

        function updatePhysics() {
            // 1. Update Incline Angle
            const rad = THREE.MathUtils.degToRad(state.angle);
            inclineGroup.rotation.z = rad; 
            
            // 2. Position Rod
            const rodWorldPos = new THREE.Vector3();
            rod.getWorldPosition(rodWorldPos);
            
            // 3. Update B Field
            updateBField();
            
            // 4. Calculate Vectors
            // Current Vector I
            let dirI = new THREE.Vector3(0, 0, 1); // Q to P (World +Z)
            if (state.currentDirection === -1) dirI.set(0, 0, -1);
            
            // Magnetic Field B
            let dirB = new THREE.Vector3(0, -1, 0); // Down
            if (state.bFieldDirection === 1) dirB.set(0, 1, 0);
            
            // Force F = I x B
            let dirF = new THREE.Vector3().crossVectors(dirI, dirB);
            
            // Update Arrow Helpers
            forceArrow.position.copy(rodWorldPos);
            forceArrow.setDirection(dirF);
            forceArrow.setLength(5);
            forceArrow.setColor(materials.arrowForce); // Ensure color

            currentArrow.position.copy(rodWorldPos);
            currentArrow.position.z -= 0.5 * state.currentDirection; // Offset
            currentArrow.setDirection(dirI);
            currentArrow.setColor(materials.arrowI);
            
            // Labels position
            lblQ.position.set(0, 0.5, -railSep/2 - 0.5);
            lblP.position.set(0, 0.5, railSep/2 + 0.5);
            
            updateWires();
        }

        // --- 4. Animation Loop ---
        
        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);
        }
        
        animate();

        // --- 5. Interactions ---

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let sphereCoords = { radius: 25, theta: Math.PI/4, phi: Math.PI/4 }; 

        function updateCamera() {
            camera.position.x = sphereCoords.radius * Math.sin(sphereCoords.theta) * Math.cos(sphereCoords.phi);
            camera.position.z = sphereCoords.radius * Math.sin(sphereCoords.theta) * Math.sin(sphereCoords.phi);
            camera.position.y = sphereCoords.radius * Math.cos(sphereCoords.theta);
            camera.lookAt(0, 0, 0);
        }
        // Initialize camera
        updateCamera();

        container.addEventListener('mousedown', (e) => { 
            isDragging = true;
            previousMousePosition = { x: e.offsetX, y: e.offsetY }; 
        });
        
        container.addEventListener('mouseup', (e) => { isDragging = false; });
        
        container.addEventListener('mousemove', (e) => {
            if(isDragging) {
                const deltaX = e.offsetX - previousMousePosition.x;
                const deltaY = e.offsetY - previousMousePosition.y;

                sphereCoords.phi -= deltaX * 0.01;
                sphereCoords.theta -= deltaY * 0.01;
                
                // Clamp theta to prevent flipping
                sphereCoords.theta = Math.max(0.1, Math.min(Math.PI - 0.1, sphereCoords.theta));

                updateCamera();
            }
            previousMousePosition = { x: e.offsetX, y: e.offsetY };
        });
        
        container.addEventListener('wheel', (e) => {
            sphereCoords.radius += e.deltaY * 0.05;
            sphereCoords.radius = Math.max(5, Math.min(50, sphereCoords.radius));
            updateCamera();
        });

        // UI Functions
        window.snapToObserverView = function() {
            sphereCoords.phi = Math.PI / 2; 
            sphereCoords.theta = Math.PI / 2; // Horizontal
            sphereCoords.radius = 25;
            updateCamera();
        }

        window.resetCamera = function() {
            sphereCoords = { radius: 25, theta: Math.PI/3, phi: Math.PI/4 };
            updateCamera();
        }
        
        // Language Translation System
        const translations = {
            en: {
                'page.title': 'Lorentz Force Simulation',
                'page.desc': 'Interactive visualization of the magnetic force on a current-carrying rod placed on inclined rails.',
                'legend.title': 'Vector Legend',
                'legend.force': '<strong>Force (F)</strong>: Resulting Lorentz force',
                'legend.current': '<strong>Current (I)</strong>: Direction of current',
                'legend.field': '<strong>Magnetic Field (B)</strong>: External vertical field',
                'physics.title': 'Physics Principle',
                'physics.desc': 'The magnetic force is defined by the cross product:',
                'physics.hint': 'Adjust the parameters below to see how the force vector changes direction and magnitude.',
                'btn.sideview': 'Switch to Side View (2D)',
                'btn.reset': 'Reset 3D View',
                'controls.hint': 'Left Click: Rotate | Right Click: Pan | Scroll: Zoom',
                'gui.angle': 'Incline Angle',
                'gui.current': 'Current Dir',
                'gui.bfield': 'B Field Dir',
                'gui.opt.into': 'Q to P (Into Screen)',
                'gui.opt.out': 'P to Q (Out of Screen)',
                'gui.opt.down': 'Down',
                'gui.opt.up': 'Up'
            },
            zh: {
                'page.title': '勞侖茲力模擬',
                'page.desc': '互動式模擬：觀察放置在傾斜軌道上的載流導體所受的磁力。',
                'legend.title': '向量圖例',
                'legend.force': '<strong>力 (F)</strong>: 產生的勞侖茲力',
                'legend.current': '<strong>電流 (I)</strong>: 電流方向',
                'legend.field': '<strong>磁場 (B)</strong>: 外部垂直磁場',
                'physics.title': '物理原理',
                'physics.desc': '磁力由以下外積定義：',
                'physics.hint': '調整下方參數以觀察力向量的方向和大小如何變化。',
                'btn.sideview': '切換至側視圖 (2D)',
                'btn.reset': '重置 3D 視角',
                'controls.hint': '左鍵：旋轉 | 右鍵：平移 | 滾輪：縮放',
                'gui.angle': '傾斜角度',
                'gui.current': '電流方向',
                'gui.bfield': '磁場方向',
                'gui.opt.into': 'Q 到 P (入紙面)',
                'gui.opt.out': 'P 到 Q (出紙面)',
                'gui.opt.down': '向下',
                'gui.opt.up': '向上'
            },
            cn: {
                'page.title': '洛伦兹力模拟',
                'page.desc': '互动式模拟：观察放置在倾斜轨道上的载流导体所受的磁力。',
                'legend.title': '向量图例',
                'legend.force': '<strong>力 (F)</strong>: 产生的洛伦兹力',
                'legend.current': '<strong>电流 (I)</strong>: 电流方向',
                'legend.field': '<strong>磁场 (B)</strong>: 外部垂直磁场',
                'physics.title': '物理原理',
                'physics.desc': '磁力由以下外积定义：',
                'physics.hint': '调整下方参数以观察力向量的方向和大小如何变化。',
                'btn.sideview': '切换至侧视图 (2D)',
                'btn.reset': '重置 3D 视角',
                'controls.hint': '左键：旋转 | 右键：平移 | 滚轮：缩放',
                'gui.angle': '倾斜角度',
                'gui.current': '电流方向',
                'gui.bfield': '磁场方向',
                'gui.opt.into': 'Q 到 P (入纸面)',
                'gui.opt.out': 'P 到 Q (出纸面)',
                'gui.opt.down': '向下',
                'gui.opt.up': '向上'
            }
        };

        let currentLang = localStorage.getItem('preferred_language') || 'en';
        let gui;

        function t(key) {
            return (translations[currentLang] && translations[currentLang][key]) || key;
        }

        function setupGUI() {
            if (gui) {
                gui.destroy();
                // Ensure DOM is cleared if destroy doesn't remove it (sometimes happens with custom appends)
                const container = document.getElementById('ui-panel');
                const oldGui = container.querySelector('.dg.main');
                if (oldGui) oldGui.remove();
            }

            gui = new dat.GUI({ autoPlace: false });
            const guiContainer = document.getElementById('ui-panel');
            guiContainer.appendChild(gui.domElement);
            
            gui.domElement.style.position = 'static';
            gui.domElement.style.marginTop = '20px';
            gui.domElement.style.width = '100%';

            gui.add(state, 'angle', 0, 60).name(t('gui.angle')).step(1);
            
            const currentOpts = {};
            currentOpts[t('gui.opt.into')] = 1;
            currentOpts[t('gui.opt.out')] = -1;
            gui.add(state, 'currentDirection', currentOpts).name(t('gui.current'));
            
            const bOpts = {};
            bOpts[t('gui.opt.down')] = -1;
            bOpts[t('gui.opt.up')] = 1;
            gui.add(state, 'bFieldDirection', bOpts).name(t('gui.bfield'));
        }

        function setLanguage(lang) {
            currentLang = lang;
            localStorage.setItem('preferred_language', lang);
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[lang] && translations[lang][key]) {
                    if (key.includes('desc') || key.includes('legend')) {
                        el.innerHTML = translations[lang][key];
                    } else {
                        el.textContent = translations[lang][key];
                    }
                }
            });
            
            document.querySelectorAll('.lang-btn').forEach(btn => {
                if (btn.getAttribute('data-lang') === lang) {
                    btn.classList.add('bg-blue-600', 'text-white');
                    btn.classList.remove('bg-gray-100');
                } else {
                    btn.classList.remove('bg-blue-600', 'text-white');
                    btn.classList.add('bg-gray-100');
                }
            });
            
            document.documentElement.lang = lang === 'cn' ? 'zh-CN' : lang === 'zh' ? 'zh-TW' : 'en';
            
            setupGUI();
        }

        window.onload = () => {
            setLanguage(currentLang);
        };

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Concave Lens Image Formation</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MathJax -->
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" id="MathJax-script"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
        }

        #three-container {
            width: 100%;
            height: 500px;
            background: #e2e8f0; /* slate-200 */
            cursor: move; /* Default to move for camera */
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            position: relative;
        }
        
        #three-container.dragging {
            cursor: col-resize !important;
        }

        /* Custom Range Slider */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #cbd5e1; /* slate-300 */
            border-radius: 4px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #2563eb; /* blue-600 */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        /* Loading spinner */
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .spinner {
            border: 3px solid rgba(37, 99, 235, 0.1);
            border-left-color: #2563eb;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }

        /* Fix MathJax layout */
        mjx-container {
            display: inline-block !important;
        }
    </style>
</head>
<body class="antialiased min-h-screen flex flex-col">

    <!-- Navigation -->
    <nav class="bg-white border-b border-slate-200 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 h-16 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <a href="index.html" class="inline-flex items-center gap-2 text-slate-600 hover:text-blue-600 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                    <span class="font-medium" data-i18n="nav.back">Back to Home</span>
                </a>
                <div class="h-6 w-px bg-slate-300 mx-2"></div>
                <div class="w-8 h-8 bg-blue-600 rounded flex items-center justify-center text-white font-bold">3D</div>
                <span class="text-xl font-bold hidden sm:inline">PhysLab<span class="text-blue-600">3D</span></span>
            </div>
            
            <div class="flex items-center gap-4">
                <!-- Language Switcher -->
                <div class="flex gap-1 bg-slate-100 p-1 rounded-lg">
                    <button onclick="setLanguage('zh')" class="lang-btn px-3 py-1 rounded-md text-xs font-medium transition hover:bg-white hover:shadow-sm" data-lang="zh">繁</button>
                    <button onclick="setLanguage('cn')" class="lang-btn px-3 py-1 rounded-md text-xs font-medium transition hover:bg-white hover:shadow-sm" data-lang="cn">简</button>
                    <button onclick="setLanguage('en')" class="lang-btn px-3 py-1 rounded-md text-xs font-medium transition hover:bg-white hover:shadow-sm bg-white shadow-sm text-blue-600" data-lang="en">EN</button>
                </div>
            </div>
        </div>
    </nav>

    <main class="flex-grow max-w-7xl mx-auto px-4 py-8 space-y-6 w-full">
        
        <!-- Header Section -->
        <header class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
            <h1 class="text-3xl font-bold text-slate-800 mb-2" data-i18n="page.title">Concave Lens Image Formation</h1>
            <p class="text-slate-600 max-w-3xl leading-relaxed" data-i18n="page.description">
                Explore how a concave lens forms images. Concave lenses always produce virtual, upright, and diminished images. Adjust the object distance to see how the image position changes.
            </p>
        </header>

        <!-- Main Workspace -->
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
            
            <!-- Left Column: Controls (4 cols) -->
            <div class="lg:col-span-4 space-y-6">
                
                <!-- Controls Panel -->
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200 space-y-6">
                    <div class="flex justify-between items-center pb-4 border-b border-slate-100">
                        <h3 class="font-bold text-slate-800 flex items-center gap-2">
                            <svg class="w-5 h-5 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                            <span data-i18n="controls.title">Variables</span>
                        </h3>
                        <button id="reset-sim" class="text-xs text-blue-600 font-bold hover:text-blue-700 transition" data-i18n="controls.reset">Reset</button>
                    </div>

                    <!-- Object Distance (u) -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700" data-i18n="controls.u">Object Distance ($u$)</label>
                            <span id="val-u" class="text-sm font-bold text-blue-600 font-mono">20.0 cm</span>
                        </div>
                        <input type="range" id="slider-u" min="5" max="40" step="0.5" value="20">
                    </div>

                    <!-- Focal Length (f) -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700" data-i18n="controls.f">Focal Length ($f$)</label>
                            <span id="val-f" class="text-sm font-bold text-blue-600 font-mono">-10.0 cm</span>
                        </div>
                        <!-- Display absolute value for slider logic but internal calculation uses negative -->
                        <input type="range" id="slider-f" min="5" max="25" step="0.5" value="10">
                    </div>

                    <!-- Object Height (h) -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-medium text-slate-700" data-i18n="controls.h">Object Height ($h_o$)</label>
                            <span id="val-h" class="text-sm font-bold text-blue-600 font-mono">5.0 cm</span>
                        </div>
                        <input type="range" id="slider-h" min="2" max="10" step="0.5" value="5">
                    </div>
                </div>

                <!-- Data Panel -->
                <div class="bg-slate-50 p-6 rounded-2xl border border-slate-200">
                    <h3 class="font-bold text-slate-800 text-sm uppercase tracking-wide mb-4" data-i18n="data.title">Real-time Data</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex justify-between items-center bg-white p-2 rounded border border-slate-100">
                            <span class="text-slate-500" data-i18n="data.v">Image Dist. ($v$)</span>
                            <span id="data-v" class="font-bold font-mono text-slate-800">-6.67 cm</span>
                        </div>
                        <div class="flex justify-between items-center bg-white p-2 rounded border border-slate-100">
                            <span class="text-slate-500" data-i18n="data.m">Magnification ($m$)</span>
                            <span id="data-m" class="font-bold font-mono text-slate-800">0.33</span>
                        </div>
                        <div class="flex justify-between items-center bg-white p-2 rounded border border-slate-100">
                            <span class="text-slate-500" data-i18n="data.type">Type</span>
                            <span id="data-type" class="font-bold text-violet-600">Virtual, Erect</span>
                        </div>
                    </div>
                </div>

                <!-- Physics Formula -->
                <div class="bg-slate-900 p-6 rounded-2xl shadow-lg text-white">
                    <h3 class="text-xs font-bold text-slate-400 uppercase tracking-widest mb-3" data-i18n="physics.title">Lens Formula</h3>
                    <div class="text-center text-xl font-serif mb-4">
                        $$ \frac{1}{f} = \frac{1}{u} + \frac{1}{v} $$
                    </div>
                    <div class="text-center text-lg font-serif mb-2 text-blue-300">
                        $$ m = -\frac{v}{u} $$
                    </div>
                    <p class="text-xs text-slate-400 text-center mt-4" data-i18n="physics.note">
                        For Concave Lens: $f$ is negative.
                    </p>
                </div>

            </div>

            <!-- Right Column: Visualization & AI (8 cols) -->
            <div class="lg:col-span-8 space-y-6">
                
                <!-- 3D Canvas -->
                <div class="relative">
                    <div id="three-container"></div>
                    
                    <!-- Overlay Controls -->
                    <div class="absolute bottom-4 left-4 flex flex-wrap gap-2 pointer-events-none">
                        <div class="bg-white/90 backdrop-blur px-3 py-1 rounded-full text-xs font-bold text-slate-600 shadow-sm border border-slate-200">
                            <span class="w-2 h-2 rounded-full bg-blue-600 inline-block mr-1"></span> <span data-i18n="legend.object">Object</span>
                        </div>
                        <div class="bg-white/90 backdrop-blur px-3 py-1 rounded-full text-xs font-bold text-slate-600 shadow-sm border border-slate-200">
                            <span class="w-2 h-2 rounded-full bg-red-600 inline-block mr-1"></span> <span data-i18n="legend.image">Image</span>
                        </div>
                        <div class="bg-white/90 backdrop-blur px-3 py-1 rounded-full text-xs font-bold text-slate-600 shadow-sm border border-slate-200">
                            <span class="w-2 h-2 rounded-full bg-amber-500 inline-block mr-1"></span> <span data-i18n="legend.rays">Light Rays</span>
                        </div>
                    </div>
                    <div class="absolute top-4 right-4 text-[10px] font-bold text-slate-400 uppercase bg-white/50 px-2 py-1 rounded backdrop-blur pointer-events-none">
                        <span data-i18n="canvas.hint">Click Object to Drag • Scroll to Zoom</span>
                    </div>
                </div>

                <!-- AI Explanation Section -->
                <div class="bg-white p-6 rounded-2xl shadow-sm border border-slate-200">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-bold text-slate-800 flex items-center gap-2">
                            <span class="text-xl">✨</span> <span data-i18n="ai.title">AI Physics Tutor</span>
                        </h2>
                    </div>
                    
                    <p class="text-slate-600 text-sm mb-4" data-i18n="ai.desc">
                        Confused about why the image is inverted or virtual? Ask our AI tutor to explain the current setup based on your slider values.
                    </p>

                    <button id="explain-button" class="w-full sm:w-auto flex items-center justify-center gap-2 px-6 py-2.5 bg-violet-600 text-white font-semibold rounded-xl hover:bg-violet-700 hover:-translate-y-0.5 transition-all shadow-sm">
                        <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        <span data-i18n="ai.btn">Explain Current Setup</span>
                    </button>

                    <!-- Loading State -->
                    <div id="gemini-loading" class="hidden mt-6 flex items-center justify-center p-4 bg-violet-50 rounded-xl">
                        <div class="spinner mr-3"></div>
                        <span class="text-violet-700 font-medium text-sm">Generating explanation...</span>
                    </div>

                    <!-- Result Area -->
                    <div id="gemini-explanation" class="hidden mt-6 p-6 bg-violet-50 border border-violet-100 rounded-xl text-slate-700 text-sm leading-relaxed prose prose-sm max-w-none">
                        <!-- AI Content -->
                    </div>
                </div>

                <!-- Feedback Section -->
                <div class="flex justify-end">
                    <button onclick="openFeedbackForm(event)" class="text-sm text-slate-500 hover:text-blue-600 font-medium flex items-center gap-1 transition">
                        <svg class="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                        <span data-i18n="btn.feedback">Send Feedback</span>
                    </button>
                </div>

            </div>
        </div>

    </main>

    <!-- Feedback Modal -->
    <div id="feedbackModal" class="hidden fixed inset-0 bg-slate-900/50 backdrop-blur-sm flex items-center justify-center p-4 z-[100]">
        <div class="bg-white rounded-2xl shadow-2xl w-full max-w-md p-6 transform transition-all scale-100">
            <h3 class="text-xl font-bold text-slate-800 mb-4" data-i18n="feedback.title">Send Us Your Feedback</h3>
            <form onsubmit="submitFeedback(event)" class="space-y-4">
                <div>
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-1" data-i18n="feedback.email">Your Email</label>
                    <input type="email" placeholder="name@example.com" required class="w-full px-4 py-2 border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition">
                </div>
                <div>
                    <label class="block text-xs font-bold text-slate-500 uppercase mb-1" data-i18n="feedback.message">Message</label>
                    <textarea placeholder="Tell us what you think..." rows="4" required class="w-full px-4 py-2 border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition"></textarea>
                </div>
                <div class="flex gap-3 pt-2">
                    <button type="submit" class="flex-1 bg-blue-600 text-white py-2.5 rounded-xl font-semibold hover:bg-blue-700 transition shadow-sm" data-i18n="feedback.send">Send Feedback</button>
                    <button type="button" onclick="closeFeedbackForm()" class="flex-1 bg-slate-100 text-slate-700 py-2.5 rounded-xl font-semibold hover:bg-slate-200 transition" data-i18n="feedback.cancel">Cancel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Script Logic -->
    <script>
        // --- State Management ---
        const state = {
            u: 20, // Object distance
            f: -10, // Focal length (negative for concave)
            h: 5   // Object height
        };

        // --- Three.js Setup ---
        let scene, camera, renderer, objectArrow, imageArrow, lensMesh, raysGroup, axisLine, fPointsGroup;
        let labelsGroup, dimensionsGroup;
        let raycaster, mouse, plane;
        let isDraggingObject = false;
        let arrowHeadGeom, arrowStemGeom; // Reusable geometries
        let dashedTexture; // For virtual image

        const container = document.getElementById('three-container');

        function initThree() {
            // Generate dashed texture
            dashedTexture = createDashedTexture();
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf1f5f9); // slate-100

            // Camera
            camera = new THREE.PerspectiveCamera(45, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            camera.position.set(0, 10, 50);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Optical Axis
            const axisGeom = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-100, 0, 0),
                new THREE.Vector3(100, 0, 0)
            ]);
            const axisMat = new THREE.LineBasicMaterial({ color: 0x94a3b8 }); // slate-400
            axisLine = new THREE.Line(axisGeom, axisMat);
            scene.add(axisLine);

            // Lens (Concave Shape)
            // Concave lens is thinner in middle.
            // We can approximate with a cylinder minus spheres or just a cylinder for schematic, 
            // but let's try to make it look concave using CSG or custom geometry? 
            // Simple visual hack: Two sphere geometries subtracted? 
            // For now, let's use a Cylinder with a custom shape or just a simple disk that represents the lens plane,
            // visually represented as "Concave" ( ) shape.
            // Actually, a Torus looks like a thick rim, which is what a concave lens is.
            // Inner part is thin.
            
            const lensGroup = new THREE.Group();
            
            // Rim (Thick)
            const rimGeom = new THREE.CylinderGeometry(10, 10, 2, 32, 1, true);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0,
                roughness: 0,
                transmission: 0.95,
                thickness: 2,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                ior: 1.5,
                clearcoat: 1
            });
            const rim = new THREE.Mesh(rimGeom, glassMat);
            rim.rotation.x = Math.PI / 2; // Cylinder along Z? No, Cylinder is along Y default. 
            // We want axis along X. Lens lies in YZ plane.
            // Cylinder Y axis. Rotate Z 90 deg.
            rim.rotation.z = Math.PI / 2;
            // lensGroup.add(rim);

            // Let's use a simple Cylinder that is thin in middle? 
            // Visualizing Concave lens: ) (
            // We can use a RingGeometry and scale it? 
            // Let's just use a Cylinder and rely on the ray diagram to show it's concave.
            // Or use a Tube geometry?
            
            // Visual Representation: ) (
            // Left curve: Part of sphere. Right curve: Part of sphere.
            // Sphere at -R, radius R. Sphere at +R, radius R.
            // Intersection is... nothing.
            // Union is nothing.
            // Concave lens is Rectangle minus Spheres.
            // Let's stick to a simple thin cylinder for the "Lens Plane" 
            // and add a visual icon or just the glass material.
            // To make it look distinct from Convex: 
            // Convex was bulging. Concave should be flat or indented.
            // Let's use a Cylinder with opacity.
            
            const cylGeom = new THREE.CylinderGeometry(10, 10, 0.5, 32);
            const cyl = new THREE.Mesh(cylGeom, glassMat);
            cyl.rotation.z = Math.PI / 2;
            lensGroup.add(cyl);
            
            // Add "Rim" to show it's thick at edges
            const outerRimGeom = new THREE.TorusGeometry(10, 0.5, 16, 100);
            const outerRim = new THREE.Mesh(outerRimGeom, new THREE.MeshBasicMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.5 }));
            outerRim.rotation.y = Math.PI / 2;
            lensGroup.add(outerRim);

            scene.add(lensGroup);
            lensMesh = lensGroup;

            // Object Arrow (Blue)
            objectArrow = createArrow(0x2563eb);
            objectArrow.name = "objectArrow"; // For raycasting
            scene.add(objectArrow);

            // Image Arrow (Red)
            imageArrow = createArrow(0xdc2626);
            scene.add(imageArrow);

            // Rays Group
            raysGroup = new THREE.Group();
            scene.add(raysGroup);

            // Helper Geometries for Rays
            arrowHeadGeom = new THREE.ConeGeometry(0.3, 0.6, 8);
            arrowHeadGeom.rotateX(Math.PI / 2);

            // Focal Points & Markers
            fPointsGroup = new THREE.Group();
            scene.add(fPointsGroup);
            
            // Labels & Dimensions
            labelsGroup = new THREE.Group();
            scene.add(labelsGroup);
            
            dimensionsGroup = new THREE.Group();
            scene.add(dimensionsGroup);

            // Raycaster for interaction
            raycaster = new THREE.Raycaster();
            raycaster.params.Line.threshold = 1;
            mouse = new THREE.Vector2();
            plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Z=0 plane

            updateSimulation();
            animate();
        }

        function createArrow(color) {
            const group = new THREE.Group();
            const stemGeom = new THREE.CylinderGeometry(0.2, 0.2, 1, 16);
            const headGeom = new THREE.ConeGeometry(0.5, 1, 16);
            
            // Use MeshStandardMaterial for better lighting/texture support
            const mat = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.5,
                metalness: 0.1
            });
            
            const stem = new THREE.Mesh(stemGeom, mat.clone()); // Clone so we can modify independently if needed
            stem.position.y = 0.5;
            stem.scale.y = 1; 
            
            const head = new THREE.Mesh(headGeom, mat.clone());
            head.position.y = 1.5;

            // Hitbox for easier dragging
            const hitGeom = new THREE.CylinderGeometry(1, 1, 2, 8);
            const hitMat = new THREE.MeshBasicMaterial({ visible: false });
            const hitbox = new THREE.Mesh(hitGeom, hitMat);
            hitbox.position.y = 1;
            hitbox.name = "hitbox";
            
            group.add(stem);
            group.add(head);
            group.add(hitbox);
            return group;
        }

        function createDashedTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Background transparent (or white if using as alpha map? Alpha map: White=Opaque, Black=Transparent)
            ctx.fillStyle = '#000000'; // Transparent
            ctx.fillRect(0, 0, 64, 64);
            
            // Draw white stripes (Opaque parts)
            ctx.fillStyle = '#FFFFFF';
            const numStripes = 8;
            const stripeHeight = 64 / numStripes;
            // Draw every other stripe
            for (let i = 0; i < numStripes; i+=2) {
                ctx.fillRect(0, i * stripeHeight, 64, stripeHeight);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 4); // Repeat vertically
            texture.magFilter = THREE.NearestFilter; // Sharp edges
            return texture;
        }

        function createTextSprite(text, colorStr = "#475569") {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const fontSize = 64;
            ctx.font = `bold ${fontSize}px Inter, sans-serif`;
            const width = ctx.measureText(text).width;
            canvas.width = width + 20;
            canvas.height = fontSize + 20;
            
            ctx.font = `bold ${fontSize}px Inter, sans-serif`;
            ctx.fillStyle = colorStr;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(canvas.width / 20, canvas.height / 20, 1);
            return sprite;
        }

        function updateSimulation() {
            const u = state.u;
            const f = state.f; // This is negative for Concave
            const h = state.h;

            // Physics Calculation
            // 1/v = 1/f - 1/u
            // v = (u*f) / (u-f)
            // For Concave: f < 0, u > 0.
            // u - f = u - (-val) = u + val > 0.
            // u * f = negative.
            // So v is always negative (Virtual, same side as object).
            
            let v = (u * f) / (u - f);
            let m = -v / u; // Magnification
            // Since v is negative and u is positive, m is positive (Erect).
            // Since |v| < |u| (because 1/v = 1/f - 1/u, |1/v| > |1/u|), m < 1 (Diminished).

            let isVirtual = v < 0; 

            // Update UI Data
            document.getElementById('data-v').textContent = `${v.toFixed(2)} cm`;
            document.getElementById('data-m').textContent = `${Math.abs(m).toFixed(2)}`;
            
            let typeText = "Virtual, Erect";
            const typeEl = document.getElementById('data-type');
            typeEl.textContent = typeText;
            typeEl.className = `font-bold text-violet-600`;

            // --- 3D Updates ---

            // 1. Position Object
            objectArrow.position.set(-u, 0, 0);
            updateArrowScale(objectArrow, h);

            // 2. Position Image
            imageArrow.visible = true;
            imageArrow.position.set(v, 0, 0); // v is negative, so on left side
            
            const h_prime = h * m;
            const absH = Math.abs(h_prime);
            updateArrowScale(imageArrow, absH);
            
            // Image is always erect for concave lens
            imageArrow.rotation.z = 0;

            imageArrow.children.forEach(mesh => {
                if (mesh.name === 'hitbox') return;
                
                // Always virtual
                mesh.material.alphaMap = dashedTexture;
                mesh.material.transparent = true;
                mesh.material.opacity = 1.0; 
                mesh.material.side = THREE.DoubleSide; 
                mesh.material.needsUpdate = true;
            });

            // 3. Focal Points & Markers
            // f is negative. Markers at +/- |f|
            updateFocalPoints(Math.abs(f));

            // 4. Dimension Lines
            updateDimensionLines(u, v);

            // 5. Draw Rays
            drawRays(u, h, f, v, h_prime);
        }

        function updateArrowScale(arrowGroup, height) {
            const scale = height / 2;
            arrowGroup.scale.set(1, scale, 1);
        }

        function updateFocalPoints(f_abs) {
            while(fPointsGroup.children.length > 0) fPointsGroup.remove(fPointsGroup.children[0]);
            while(labelsGroup.children.length > 0) labelsGroup.remove(labelsGroup.children[0]);

            const fMat = new THREE.MeshBasicMaterial({ color: 0x475569 });
            const fGeom = new THREE.SphereGeometry(0.3, 16, 16);

            const positions = [
                { x: -f_abs, label: "F" },
                { x: f_abs, label: "F" },
                { x: -2*f_abs, label: "2F" },
                { x: 2*f_abs, label: "2F" }
            ];

            positions.forEach(pos => {
                const mesh = new THREE.Mesh(fGeom, fMat);
                mesh.position.set(pos.x, 0, 0);
                fPointsGroup.add(mesh);

                const label = createTextSprite(pos.label);
                label.position.set(pos.x, -1.5, 0);
                labelsGroup.add(label);
            });
        }

        function updateDimensionLines(u, v) {
            while(dimensionsGroup.children.length > 0) dimensionsGroup.remove(dimensionsGroup.children[0]);

            const lineMat = new THREE.LineBasicMaterial({ color: 0x64748b });
            
            function drawDim(start, end, labelText, yOffset) {
                const pts = [new THREE.Vector3(start, yOffset, 0), new THREE.Vector3(end, yOffset, 0)];
                const geom = new THREE.BufferGeometry().setFromPoints(pts);
                const line = new THREE.Line(geom, lineMat);
                dimensionsGroup.add(line);

                const tickH = 0.5;
                const tick1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(start, yOffset - tickH, 0), new THREE.Vector3(start, yOffset + tickH, 0)
                ]), lineMat);
                const tick2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([
                    new THREE.Vector3(end, yOffset - tickH, 0), new THREE.Vector3(end, yOffset + tickH, 0)
                ]), lineMat);
                dimensionsGroup.add(tick1);
                dimensionsGroup.add(tick2);

                const label = createTextSprite(labelText, "#64748b");
                label.position.set((start + end) / 2, yOffset - 1, 0);
                label.scale.set(3, 1.5, 1); 
                dimensionsGroup.add(label);
            }

            drawDim(0, -u, `u = ${u}cm`, -5);
            
            // v is negative, so it's on the left (0 to v)
            if (Math.abs(v) < 200) {
                drawDim(0, v, `v = ${Math.abs(v).toFixed(1)}cm`, -7);
            }
        }

        function drawRays(u, h, f, v, h_prime) {
            while(raysGroup.children.length > 0) raysGroup.remove(raysGroup.children[0]);

            const rayColor = 0xf59e0b; // Amber-500
            const rayMat = new THREE.LineBasicMaterial({ color: rayColor, linewidth: 2 });
            const dashMat = new THREE.LineDashedMaterial({ color: rayColor, dashSize: 1, gapSize: 1, opacity: 0.5, transparent: true });

            const objTop = new THREE.Vector3(-u, h, 0);
            const imgTop = new THREE.Vector3(v, h_prime, 0);
            const lensHit1 = new THREE.Vector3(0, h, 0);
            const lensCenter = new THREE.Vector3(0, 0, 0);
            
            // For Concave: f is negative (Left side)
            // But Parallel Ray diverges *as if coming from* Focal Point on the same side (Left F).
            const fLeft = new THREE.Vector3(f, 0, 0); // f is -10
            
            // Helper to add segment with arrow
            function addSegment(p1, p2, material, addArrow=true) {
                const geom = new THREE.BufferGeometry().setFromPoints([p1, p2]);
                const line = new THREE.Line(geom, material);
                if (material === dashMat) line.computeLineDistances();
                raysGroup.add(line);

                if (addArrow) {
                    const dir = new THREE.Vector3().subVectors(p2, p1).normalize();
                    const len = p1.distanceTo(p2);
                    if (len > 2) { 
                        const arrow = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), new THREE.MeshBasicMaterial({ color: rayColor }));
                        arrow.position.copy(p1).add(dir.multiplyScalar(len / 2)); 
                        arrow.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir.normalize());
                        raysGroup.add(arrow);
                    }
                }
            }

            // Ray 1: Parallel to Axis -> Lens -> Diverges (appears to come from F_left)
            addSegment(objTop, lensHit1, rayMat);
            
            // Diverging path
            // Direction: From F_left through LensHit1 and outwards
            const dir1 = new THREE.Vector3().subVectors(lensHit1, fLeft).normalize();
            const farPoint1 = lensHit1.clone().add(dir1.multiplyScalar(50));
            addSegment(lensHit1, farPoint1, rayMat);
            
            // Virtual trace back to F_left (and Image Top)
            // Draw dashed from LensHit1 back to F_left (which passes through ImageTop)
            addSegment(fLeft, lensHit1, dashMat, false);

            // Ray 2: Through Center -> Undeviated
            const dir2 = new THREE.Vector3().subVectors(lensCenter, objTop).normalize();
            const farPoint2 = objTop.clone().add(dir2.multiplyScalar(60));
            addSegment(objTop, farPoint2, rayMat);
            // No virtual trace needed as it overlaps, but for consistency:
            // addSegment(objTop, lensCenter, dashMat, false); 
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // --- Interaction ---
        
        // Drag Logic
        container.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        function onMouseDown(e) {
            e.preventDefault();
            const rect = container.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObject(objectArrow, true); 
            
            if (intersects.length > 0) {
                isDraggingObject = true;
                container.classList.add('dragging');
            } else {
                isCameraDrag = true;
                startCamX = e.clientX;
                startCamY = e.clientY;
            }
        }

        function onMouseMove(e) {
            if (isDraggingObject) {
                const rect = container.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersect = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersect);

                let newU = -intersect.x;
                newU = Math.max(5, Math.min(40, newU)); 
                
                state.u = newU;
                document.getElementById('slider-u').value = newU;
                document.getElementById('val-u').textContent = newU.toFixed(1) + " cm";
                updateSimulation();
            } else if (isCameraDrag) {
                const deltaX = (e.clientX - startCamX) * 0.005;
                const deltaY = (e.clientY - startCamY) * 0.005;
                startCamX = e.clientX;
                startCamY = e.clientY;

                theta -= deltaX;
                phi -= deltaY;
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

                camera.position.x = radius * Math.sin(phi) * Math.sin(theta);
                camera.position.y = radius * Math.cos(phi);
                camera.position.z = radius * Math.sin(phi) * Math.cos(theta);
                camera.lookAt(0, 0, 0);
            }
        }

        function onMouseUp() {
            isDraggingObject = false;
            isCameraDrag = false;
            container.classList.remove('dragging');
        }

        // Sliders
        document.getElementById('slider-u').addEventListener('input', (e) => {
            state.u = parseFloat(e.target.value);
            document.getElementById('val-u').textContent = state.u.toFixed(1) + " cm";
            updateSimulation();
        });
        document.getElementById('slider-f').addEventListener('input', (e) => {
            // Slider value is positive magnitude, state.f is negative
            state.f = -parseFloat(e.target.value);
            document.getElementById('val-f').textContent = state.f.toFixed(1) + " cm";
            updateSimulation();
        });
        document.getElementById('slider-h').addEventListener('input', (e) => {
            state.h = parseFloat(e.target.value);
            document.getElementById('val-h').textContent = state.h.toFixed(1) + " cm";
            updateSimulation();
        });

        document.getElementById('reset-sim').addEventListener('click', () => {
            state.u = 20; state.f = -10; state.h = 5;
            document.getElementById('slider-u').value = 20;
            document.getElementById('slider-f').value = 10;
            document.getElementById('slider-h').value = 5;
            document.getElementById('val-u').textContent = "20.0 cm";
            document.getElementById('val-f').textContent = "-10.0 cm";
            document.getElementById('val-h').textContent = "5.0 cm";
            updateSimulation();
        });

        // Camera Vars
        let isCameraDrag = false;
        let startCamX, startCamY;
        let radius = 51;
        let theta = 0;
        let phi = Math.acos(10/51);

        // Zoom
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            radius += e.deltaY * 0.05;
            radius = Math.max(10, Math.min(100, radius));
            camera.position.x = radius * Math.sin(phi) * Math.sin(theta);
            camera.position.y = radius * Math.cos(phi);
            camera.position.z = radius * Math.sin(phi) * Math.cos(theta);
            camera.lookAt(0, 0, 0);
        });

        // Initialize
        initThree();

        // --- Gemini API & Feedback ---
        async function callGeminiAPI(userQuery) {
             return new Promise(resolve => setTimeout(() => resolve("<b>AI Explanation:</b><br>For a concave lens, the image is always virtual, erect, and diminished, regardless of the object position."), 1000));
        }
        
        document.getElementById('explain-button').addEventListener('click', async () => {
            const output = document.getElementById('gemini-explanation');
            const loading = document.getElementById('gemini-loading');
            loading.classList.remove('hidden');
            output.classList.add('hidden');
            const text = await callGeminiAPI();
            output.innerHTML = text;
            loading.classList.add('hidden');
            output.classList.remove('hidden');
        });

        function openFeedbackForm(e) { e.preventDefault(); document.getElementById('feedbackModal').classList.remove('hidden'); }
        function closeFeedbackForm() { document.getElementById('feedbackModal').classList.add('hidden'); }
        function submitFeedback(e) { e.preventDefault(); alert("Sent!"); closeFeedbackForm(); }

        // --- Language System ---
        const translations = {
            en: {
                'nav.back': 'Back to Home',
                'page.title': 'Concave Lens Image Formation',
                'page.description': 'Explore how a concave lens forms images. Concave lenses always produce virtual, upright, and diminished images. Adjust the object distance to see how the image position changes.',
                'controls.title': 'Variables',
                'controls.reset': 'Reset',
                'controls.u': 'Object Distance ($u$)',
                'controls.f': 'Focal Length ($f$)',
                'controls.h': 'Object Height ($h_o$)',
                'data.title': 'Real-time Data',
                'data.v': 'Image Dist. ($v$)',
                'data.m': 'Magnification ($m$)',
                'data.type': 'Type',
                'physics.title': 'Lens Formula',
                'physics.note': 'For Concave Lens: $f$ is negative.',
                'legend.object': 'Object',
                'legend.image': 'Image',
                'legend.rays': 'Light Rays',
                'canvas.hint': 'Click Object to Drag • Scroll to Zoom',
                'ai.title': 'AI Physics Tutor',
                'ai.desc': 'Confused about why the image is inverted or virtual? Ask our AI tutor to explain the current setup.',
                'ai.btn': 'Explain Current Setup',
                'btn.feedback': 'Send Feedback',
                'feedback.title': 'Send Us Your Feedback',
                'feedback.email': 'Your Email',
                'feedback.message': 'Message',
                'feedback.send': 'Send Feedback',
                'feedback.cancel': 'Cancel'
            },
            zh: {
                'nav.back': '返回首頁',
                'page.title': '凹透鏡成像模擬',
                'page.description': '探索凹透鏡如何形成影像。凹透鏡總是產生虛像、正立和縮小的影像。調整物距以觀察影像位置的變化。',
                'controls.title': '變數控制',
                'controls.reset': '重設',
                'controls.u': '物距 ($u$)',
                'controls.f': '焦距 ($f$)',
                'controls.h': '物體高度 ($h_o$)',
                'data.title': '即時數據',
                'data.v': '像距 ($v$)',
                'data.m': '放大倍率 ($m$)',
                'data.type': '性質',
                'physics.title': '透鏡公式',
                'physics.note': '凹透鏡：$f$ 為負值。',
                'legend.object': '物體',
                'legend.image': '影像',
                'legend.rays': '光線',
                'canvas.hint': '點擊物體拖曳 • 滾輪縮放',
                'ai.title': 'AI 物理導師',
                'ai.desc': '不明白為什麼影像是倒立或虛像？詢問我們的 AI 導師來解釋當前的設置。',
                'ai.btn': '解釋當前設置',
                'btn.feedback': '發送反饋',
                'feedback.title': '發送您的反饋',
                'feedback.email': '您的電子郵件',
                'feedback.message': '訊息',
                'feedback.send': '發送反饋',
                'feedback.cancel': '取消'
            },
            cn: {
                'nav.back': '返回首页',
                'page.title': '凹透镜成像模拟',
                'page.description': '探索凹透镜如何形成影像。凹透镜总是产生虚像、正立和缩小的影像。调整物距以观察影像位置的变化。',
                'controls.title': '变数控制',
                'controls.reset': '重设',
                'controls.u': '物距 ($u$)',
                'controls.f': '焦距 ($f$)',
                'controls.h': '物体高度 ($h_o$)',
                'data.title': '即时数据',
                'data.v': '像距 ($v$)',
                'data.m': '放大倍率 ($m$)',
                'data.type': '性质',
                'physics.title': '透镜公式',
                'physics.note': '凹透镜：$f$ 为负值。',
                'legend.object': '物体',
                'legend.image': '影像',
                'legend.rays': '光线',
                'canvas.hint': '点击物体拖曳 • 滚轮缩放',
                'ai.title': 'AI 物理导师',
                'ai.desc': '不明白为什么影像是倒立或虚像？询问我们的 AI 导师来解释当前的设置。',
                'ai.btn': '解释当前设置',
                'btn.feedback': '发送反馈',
                'feedback.title': '发送您的反馈',
                'feedback.email': '您的电子邮件',
                'feedback.message': '讯息',
                'feedback.send': '发送反馈',
                'feedback.cancel': '取消'
            }
        };

        function setLanguage(lang) {
            localStorage.setItem('preferred_language', lang);
            document.documentElement.lang = lang === 'cn' ? 'zh-CN' : lang === 'zh' ? 'zh-TW' : 'en';
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (translations[lang] && translations[lang][key]) {
                    el.textContent = translations[lang][key];
                }
            });

            // Re-render MathJax
            if (window.MathJax && window.MathJax.typesetPromise) {
                window.MathJax.typesetPromise();
            }
        }

        const savedLang = localStorage.getItem('preferred_language') || 'en';
        setLanguage(savedLang);

    </script>
</body>
</html>
